theory Scratch
  imports Main
begin

section‚Äπ100 Doors‚Ä∫

  datatype doorstate = Open | Closed

  fun toggle :: "doorstate ‚áí doorstate" where
    "toggle Open   = Closed"
  | "toggle Closed = Open"

  fun walk :: "('a ‚áí 'a) ‚áí nat ‚áí nat ‚áí 'a list ‚áí 'a list" where
    "walk f _     _       []     = []"
  | "walk f every 0       (x#xs) = (f x) # walk f every every xs"
  | "walk f every (Suc n) (x#xs) = x # walk f every n xs"

  text‚ÄπExample: \<^const>‚Äπtoggle‚Ä∫ every second door. (second = 1, because of 0 indexing)‚Ä∫
  lemma "walk toggle 1 1 [Open, Open, Open, Open, Open, Open] =
                         [Open, Closed, Open, Closed, Open, Closed]" by code_simp

  text‚ÄπExample: \<^const>‚Äπtoggle‚Ä∫ every third door.‚Ä∫
  lemma "walk toggle 2 2 [Open, Open, Open, Open, Open, Open] =
                         [Open, Open, Closed, Open, Open, Closed]" by code_simp

  text‚ÄπWalking each door is essentially the same as the common \<^const>‚Äπmap‚Ä∫ function.‚Ä∫
  lemma "walk f 0 0 xs = map f xs"
    by(induction xs) (simp)+

  lemma walk_beginning:
    "walk f every n xs = (walk f every n (take (Suc n) xs)) @ (walk f every every (drop (Suc n) xs))"
    by(induction f every n xs rule:walk.induct) (simp)+

  text‚ÄπA convenience definition to take the off-by-one into account and setting the starting position.‚Ä∫
  definition visit_every :: "('a ‚áí 'a) ‚áí nat ‚áí 'a list ‚áí 'a list" where
    "visit_every f every xs ‚â° walk f (every - 1) (every - 1) xs"


  fun iterate :: "nat ‚áí (nat ‚áí 'a ‚áí 'a) ‚áí nat ‚áí 'a ‚áí 'a" where
    "iterate 0       _ _ a = a"
  | "iterate (Suc i) f n a = iterate i f (Suc n) (f n a)"

  text‚ÄπThe 100 doors problem.‚Ä∫
  definition "onehundred_doors ‚â° iterate 100 (visit_every toggle) 1 (replicate 100 Closed)"

  lemma "onehundred_doors =
    [Open, Closed, Closed, Open, Closed, Closed, Closed,
     Closed, Open, Closed, Closed, Closed, Closed, Closed,
     Closed, Open, Closed, Closed, Closed, Closed, Closed,
     Closed, Closed, Closed, Open, Closed, Closed, Closed,
     Closed, Closed, Closed, Closed, Closed, Closed, Closed,
     Open, Closed, Closed, Closed, Closed, Closed, Closed,
     Closed, Closed, Closed, Closed, Closed, Closed, Open,
     Closed, Closed, Closed, Closed, Closed, Closed, Closed,
     Closed, Closed, Closed, Closed, Closed, Closed, Closed,
     Open, Closed, Closed, Closed, Closed, Closed, Closed,
     Closed, Closed, Closed, Closed, Closed, Closed, Closed,
     Closed, Closed, Closed, Open, Closed, Closed, Closed,
     Closed, Closed, Closed, Closed, Closed, Closed, Closed,
     Closed, Closed, Closed, Closed, Closed, Closed, Closed,
     Closed, Open]" by code_simp

  text‚ÄπFiltering for the open doors, we get the same result as the Haskell implementation.‚Ä∫
  lemma
    "[(i, door) ‚Üê enumerate 1 onehundred_doors. door = Open] =
     [(1,Open),(4,Open),(9,Open),(16,Open),(25,Open),(36,Open),(49,Open),(64,Open),(81,Open),(100,Open)]"
    by code_simp

section‚ÄπEquivalence to Haskell Implementation‚Ä∫
text‚Äπ
We will now present an alternative implementation, which is similar to the Haskell implementation
on üåê‚Äπhttps://rosettacode.org/wiki/100_doors#Haskell‚Ä∫. We will prove, that the two behave the same;
in general, not just for a fixed set of 100 doors.
‚Ä∫

  definition map_every_start :: "('a ‚áí 'a) ‚áí nat ‚áí nat ‚áí 'a list ‚áí 'a list" where
    "map_every_start f every start xs ‚â°
      map (Œª(i, x). if i mod every = 0 then f x else x) (enumerate start xs)"

  definition visit_every_alt :: "('a ‚áí 'a) ‚áí nat ‚áí 'a list ‚áí 'a list" where
    "visit_every_alt f every xs ‚â° map_every_start f every 1 xs"

  text‚ÄπEssentially, \<^term>‚Äπstart‚Ä∫ and \<^term>‚Äπstart mod every‚Ä∫ behave the same.‚Ä∫
  lemma map_every_start_cycle:
    "map_every_start f every (start + k*every) xs = map_every_start f every start xs"
    proof(induction xs arbitrary: start)
      case Nil
      show "map_every_start f every (start + k * every) [] = map_every_start f every start []"
        by(simp add: map_every_start_def)
    next
      case (Cons x xs)
      from Cons.IH[of "Suc start"]
        show "map_every_start f every (start + k * every) (x # xs) =
              map_every_start f every start (x # xs)"
        by(simp add: map_every_start_def)
    qed
  corollary map_every_start_cycle_zero:
    "map_every_start f every every xs = map_every_start f every 0 xs"
    using map_every_start_cycle[where k=1 and start=0, simplified] by blast

  lemma map_every_start_fst_zero:
    "map_every_start f every 0 (x # xs) = f x # map_every_start f every (Suc 0) xs"
    by(simp add: map_every_start_def)

  text‚Äπ
  The first \<^term>‚Äπn‚Ä∫ elements are not processed by \<^term>‚Äπf‚Ä∫,
  as long as \<^term>‚Äπn‚Ä∫ is less than the \<^term>‚Äπevery‚Ä∫ cycle.
  ‚Ä∫
  lemma map_every_start_skip_first: "Suc n < every ‚üπ
         map_every_start f every (every - (Suc n)) (x # xs) =
         x # map_every_start f every (every - n) xs"
    by(simp add: map_every_start_def Suc_diff_Suc)

  lemma map_every_start_append:
    "map_every_start f n s (ds1 @ ds2) =
     map_every_start f n s ds1 @ map_every_start f n (s + length ds1) ds2"
    by(simp add: map_every_start_def enumerate_append_eq)

  text‚Äπ
  The \<^const>‚Äπwalk‚Ä∫ function and \<^const>‚Äπmap_every_start‚Ä∫ behave the same,
  as long as the starting \<^term>‚Äπn‚Ä∫ is less than the \<^term>‚Äπevery‚Ä∫ cycle,
  because \<^const>‚Äπwalk‚Ä∫ allows pushing the start arbitrarily far and
  \<^const>‚Äπmap_every_start‚Ä∫ only allows deferring the start within
  the \<^term>‚Äπevery‚Ä∫ cycle.
  This generalization is needed to strengthen the induction hypothesis
  for the proof.
  ‚Ä∫
  lemma walk_eq_map_every_start:
    "n ‚â§ every ‚üπ walk f every n xs = map_every_start f (Suc every) (Suc every - n) xs"
    proof(induction xs arbitrary: n)
      case Nil
      show "walk f every n [] = map_every_start f (Suc every) (Suc every - n) []"
        by(simp add: map_every_start_def)
    next
      case (Cons x xs)
      then show "walk f every n (x # xs) = map_every_start f (Suc every) (Suc every - n) (x # xs)"
      proof(cases n)
        case 0
        with Cons.IH show ?thesis
          by(simp add: map_every_start_cycle_zero map_every_start_fst_zero)
      next
        case (Suc n2)
        with Cons.prems map_every_start_skip_first[of n2 "Suc every"] have
          "map_every_start f (Suc every) (Suc every - Suc n2) (x # xs) =
           x # map_every_start f (Suc every) (Suc every - n2) xs"
          by fastforce
        with Suc Cons show ?thesis
          by(simp)
      qed
    qed

  corollary walk_eq_visit_every_alt:
    "walk f every every xs = visit_every_alt f (Suc every) xs"
    unfolding visit_every_alt_def
    using walk_eq_map_every_start by fastforce

  text‚Äπ
  Despite their very different implementations, our alternative visit function behaves the same
  as our original visit function.
  Text the theorem includes \<^term>‚ÄπSuc every‚Ä∫ to express that we exclude \<^term>‚Äπevery = 0‚Ä∫.
  ‚Ä∫
  theorem visit_every_eq_visit_every_alt:
    "visit_every f (Suc every) xs = visit_every_alt f (Suc every) xs"
    unfolding visit_every_def
    using walk_eq_visit_every_alt by fastforce

  text‚ÄπAlso, the \<^const>‚Äπiterate‚Ä∫ function we implemented above can be implemented by a simple \<^const>‚Äπfold‚Ä∫.‚Ä∫
  lemma fold_upt_helper: assumes n_geq_1: "Suc 0 ‚â§ n"
    shows "fold f [Suc s..<n + s] (f s xs) = fold f [s..<n + s] xs"
  proof -
    from n_geq_1 have "[s..<n + s] = s#[Suc s..<n + s]" by (simp add: Suc_le_lessD upt_rec)
    from this have "fold f [s..<n + s] xs = fold f (s#[Suc s..<n + s]) xs" by simp
    also have "fold f (s#[Suc s..<n + s]) xs = fold f [Suc s..<n + s] (f s xs)" by(simp)
    ultimately show ?thesis by simp
  qed

  theorem iterate_eq_fold: "iterate n f s xs = fold f [s ..< n+s] xs"
  proof(induction n arbitrary: s xs)
    case 0
    then show "iterate 0 f s xs = fold f [s..<0 + s] xs" by simp
  next
    case (Suc n)
    from Suc show "iterate (Suc n) f s xs = fold f [s..<Suc n + s] xs"
      by(simp add: fold_upt_helper not_less_eq_eq)
  qed

section‚ÄπEfficient Implementation‚Ä∫
text ‚Äπ
As noted on this page, the only doors that remain open are those whose numbers are perfect squares.
Yet, rosettacode does not want us to take this shortcut, since we want to compare implementations
across programming languages. But we can prove that our code computes the same result as reporting
all doors with a perfect square number as open:
‚Ä∫
  theorem "[(i, door) ‚Üê enumerate 1 onehundred_doors. door = Open] =
           [(i*i, Open). i ‚Üê [1..<11]]"
    by code_simp
end
