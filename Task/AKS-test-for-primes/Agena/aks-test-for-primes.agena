# AKS test for primes

constant pas_tri_max := 50;

proc pascal_triangle(n :: posint) is
# Calculate the n'th line 1.. middle
# For n = 1, 2, ..
  create register pas_tri((n + 1) \ 2);
  # pas_tri[0] always is 1
  j := 1;
  case n
    of 1, 2 then pas_tri[1] := 2
    else
      j := 3;
      pas_tri[1] := 2;
      while j <= n do
        j++;
        k := j \ 2; # middle
        pas_tri[k] := pas_tri[k - 1];
        while k >= 2 do
          pas_tri[k] +:= pas_tri[k - 1];
          k--
        od;
        pas_tri[1] +:= 1
      od
    esle
  esac
  return pas_tri
end;

proc is_prime(n :: nonnegint) :: boolean is
  if n > pas_tri_max then
    printf("%d is out of range\n", n);
    os.exit(-1)
  fi;
  pas_tri := pascal_triangle(n);
  res := true;
  i := n \ 2;
  while res and (i > 1) do
    res := res and (pas_tri[i] symmod n = 0);
    i--
  od;
  return res
end;

proc vz(b :: boolean) is
  return if b then '-' else '+' fi
end;

proc expand_poly(n :: nonnegint) is
  if n > pas_tri_max then
    printf("%d is out of range\n", n);
    os.exit(-1)
  fi;
  case n
    of 0 then printf("(x-1)^0 = 1\n");
    of 1 then printf("(x-1)^1 = x-1\n");
    else
      pas_tri := pascal_triangle(n);
      printf("(x-1)^%d = x^%d", n, n);
      bvz := true;
      n_div_2 := n \ 2
      for j from n - 1 to n_div_2 + 1 by -1 do
        printf("%s%d*x^%d", vz(bvz), pas_tri[n - j], j);
        bvz := not bvz
      od;
      for j from n_div_2 to 2 by -1 do
        printf("%s%d*x^%d", vz(bvz), pas_tri[j], j);
        bvz := not bvz
      od;
      printf("%s%d*x", vz(bvz), pas_tri[1]);
      bvz := not bvz;
      printf("%s1\n", vz(bvz));
    esle
  esac
end;

scope
  local n;
  for n from 0 to 9 do
    expand_poly(n)
  od;
  for n from 2 to pas_tri_max do
    if is_prime(n) then
      printf("%3d", n)
    fi
  od;
  printf("\n")
end
