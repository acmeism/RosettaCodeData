100H:
/* THERE IS NO STANDARD LIBRARY
   THIS DEFINES SOME BASIC I/O USING CP/M */
BDOS: PROCEDURE (F,A); DECLARE F BYTE, A ADDRESS; GO TO 5; END BDOS;
EXIT: PROCEDURE; CALL BDOS(0,0); END EXIT;
PUT$CHAR: PROCEDURE (C); DECLARE C BYTE; CALL BDOS(2,C); END PUT$CHAR;
PRINT: PROCEDURE (S); DECLARE S ADDRESS; CALL BDOS(9,S); END PRINT;
NEWLINE: PROCEDURE; CALL PRINT(.(13,10,'$')); END NEWLINE;

/* PRINT 16-BIT HEX VALUE (POINTER) */
PRINT$HEX: PROCEDURE (N);
    DECLARE N ADDRESS, (I, C) BYTE;
    DO I=0 TO 3;
        IF I <> 3 THEN C = SHR(N,12-4*I) AND 0FH;
        ELSE C = N AND 0FH;
        IF C >= 10 THEN C = C - 10 + 'A';
        ELSE C = C + '0';
        CALL PUT$CHAR(C);
    END;
END PRINT$HEX;

/* OF COURSE WE WILL NEED SOME VALUES TO POINT AT TOO */
DECLARE FOO ADDRESS INITIAL (0F00H);
DECLARE BAR ADDRESS INITIAL (0BA1H);

/* OK, NOW ON TO THE DEMONSTRATION */

/* THE ADDRESS OF A VARIABLE CAN BE RETRIEVED BY PREPENDING IT WITH A
   DOT, E.G.: */
CALL PRINT(.'FOO IS $'); CALL PRINT$HEX(FOO);
CALL PRINT(.' AND ITS ADDRESS IS $'); CALL PRINT$HEX(.FOO);
CALL NEWLINE;

CALL PRINT(.'BAR IS $'); CALL PRINT$HEX(BAR);
CALL PRINT(.' AND ITS ADDRESS IS $'); CALL PRINT$HEX(.BAR);
CALL NEWLINE;

/* PL/M DOES NOT HAVE C-STYLE POINTERS. INSTEAD IT HAS 'BASED' VARIABLES.

   WHEN A VARIABLE IS DECLARED 'BASED', ITS ADDRESS IS STORED IN ANOTHER
   VARIABLE.

   NOTE HOWEVER THAT THE 'ADDRESS' DATATYPE IS SIMPLY A 16-BIT INTEGER,
   AND DOES NOT INTRINSICALLY POINT TO ANYTHING.

   THE FOLLOWING DECLARES A VARIABLE 'POINTER', WHICH WILL HOLD AN ADDRESS,
   AND A VARIABLE 'VALUE' WHICH WILL BE LOCATED AT WHATEVER THE VALUE IN
   'POINTER' IS. */

DECLARE POINTER ADDRESS;
DECLARE VALUE BASED POINTER ADDRESS;

/* WE CAN NOW ACCESS 'FOO' AND 'BAR' THROUGH 'VALUE' BY ASSIGNING THEIR
   ADDRESSES TO 'POINTER'. */
POINTER = .FOO;
CALL PRINT(.'POINTER IS $'); CALL PRINT$HEX(POINTER);
CALL PRINT(.' AND VALUE IS $'); CALL PRINT$HEX(VALUE); CALL NEWLINE;

POINTER = .BAR;
CALL PRINT(.'POINTER IS $'); CALL PRINT$HEX(POINTER);
CALL PRINT(.' AND VALUE IS $'); CALL PRINT$HEX(VALUE); CALL NEWLINE;

/* MUTATION IS ALSO POSSIBLE OF COURSE */
VALUE = 0BA3H;
CALL PRINT(.'VALUE IS NOW $'); CALL PRINT$HEX(VALUE);
CALL PRINT(.' AND BAR IS NOW $'); CALL PRINT$HEX(BAR); CALL NEWLINE;

/* LASTLY, PL/M SUPPORTS ANONYMOUS CONSTANTS.
   YOU CAN TAKE THE ADDRESS OF AN IMMEDIATE CONSTANT, AND PL/M
   WILL STORE THE CONSTANT IN THE CONSTANT POOL AND GIVE YOU ITS
   ADDRESS. THE CONSTANT MUST HOWEVER BE A BYTE OR A LIST OF BYTES. */
POINTER = .(0FEH,0CAH); /* NOTE THE DOT, AND THE LOW-ENDIAN 16-BIT VALUE */
CALL PRINT(.'POINTER IS $'); CALL PRINT$HEX(POINTER);
CALL PRINT(.' AND VALUE IS $'); CALL PRINT$HEX(VALUE); CALL NEWLINE;

/* NOTE THAT THIS IS ALSO HOW STRINGS WORK - SEE ALL THE DOTS IN FRONT
   OF THE STRINGS IN THE 'PRINT' CALLS */
CALL EXIT;
EOF
