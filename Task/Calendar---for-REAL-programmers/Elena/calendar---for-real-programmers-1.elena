public program = PROGRAM;

CONSOLE = Console;

abstract INDEXERCLASS : interface<Indexer>
{
   abstract ISAVAILABLE();
   abstract GETINDEX();
   abstract SETINDEX(INDEX);
   abstract NEWINDEX(OFFS);
   abstract GETVALUE();
   abstract GETLENGTH();

   bool Available = ISAVAILABLE();
   int Index
   {
      get() = GETINDEX();

      set(int INDEX)
      {
         SETINDEX(INDEX);
      }
   }
   appendIndex(int OFFS) { this self.Index := NEWINDEX(OFFS) }
   set Value(o) { NotSupportedException.raise() }
   get Value() = GETVALUE();
   get int Length() { ^ GETLENGTH() }
}

PARALLELENUMERATOR(N) { ^ ParallelEnumerator.new(N) }

NEWDATE(Y,M,D) { ^ Date.new(Y,M,D) }
NEWTEXTBUILDER() { ^ new TextBuilder() }

GETMONTH(D) { ^ D.Month }
GETDAYOFWEEK(D) { ^D.DayOfWeek }
GETDAYSTR(D) { ^ D.Day.toPrintable() }

READCHAR() { Console.readChar() }
READINT(PROMPT) { ^ Console.write(PROMPT).readLine().toInt() }

WRITEPADDING(OUTPUT,S,SPACER,LEN) { OUTPUT.writePadding(S,SPACER,LEN) }
WRITEPADDINGLEFT(OUTPUT,S,SPACER,LEN) { OUTPUT.writePaddingLeft(S,SPACER,LEN) }
WRITELINE(OUTPUT) { OUTPUT.writeLine() }
WRITE(OUTPUT,S) { OUTPUT.write(S) }
WRITEARGS(OUTPUT,S1,S2) { OUTPUT.print(S1, S2) }
WRITECOPIES(OUTPUT,S,N) { OUTPUT.writeCopies(S,N) }

ALLOCATE(COUNT) { ^ Array.allocate(COUNT) }

CLEAR(S) { S.clear() }

POPULATE(OBJ, ACTION) { ^ OBJ.populate(ACTION) }
FOREACH(OBJ, ACTION) { ^ OBJ.forEach(ACTION) }

const MONTHNAMES = new string[]{"JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE","JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER"};
const DAYNAMES = new string[]{"MO", "TU", "WE", "TH", "FR", "SA", "SU"};
