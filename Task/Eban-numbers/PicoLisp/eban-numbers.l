(de _eban? (N)
   (let
      (B (/ N 1000000000)
         R (% N 1000000000)
         M (/ R 1000000)
         R (% N 1000000)
         Z (/ R 1000)
         R (% R 1000) )
      (and
         (>= M 30)
         (<= M 66)
         (setq M (% M 10)) )
      (and
         (>= Z 30)
         (<= Z 66)
         (setq Z (% Z 10)) )
      (and
         (>= R 30)
         (<= R 66)
         (setq R (% R 10)) )
      (fully
         '((S)
            (unless (bit? 1 (val S))
               (>= 6 (val S)) ) )
         '(B M Z R) ) ) )
(de eban (B A)
   (default A 2)
   (let R (cons 0 (cons))
      (for (N A (>= B N) (+ N 2))
         (and
            (_eban? N)
            (inc R)
            (push (cdr R) N) ) )
      (con R (flip (cadr R)))
      R ) )
(off R)
(prinl "eban numbers up to an including 1000:")
(setq R (eban 1000))
(println (cdr R))
(prinl "count: " (car R))
(prinl)
(prinl "eban numbers between 1000 and 4000")
(setq R (eban 4000 1000))
(println (cdr R))
(prinl "count: " (car R))
(prinl)
(prinl "eban numbers up to an including 10000:")
(prinl "count: " (car (eban 10000)))
(prinl)
(prinl "eban numbers up to an including 100000:")
(prinl "count: " (car (eban 100000)))
(prinl)
(prinl "eban numbers up to an including 1000000:")
(prinl "count: " (car (eban 1000000)))
(prinl)
(prinl "eban numbers up to an including 10000000:")
(prinl "count: " (car (eban 10000000)))
