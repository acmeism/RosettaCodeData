my (\ğ“„¤, \ğ“„Š, \ğ“†, \ğ“„°) = (0, 1, 10, 10e7);
sub infix:<ğ“‚½> { $^ğ“ƒ  + $^ğ“ƒŸ }
sub infix:<ğ“‚»> { $^ğ“ƒ² - $^ğ“†Š }
sub infix:<ğ“ˆ> { $^ğ“ƒ• < $^ğ“ƒ¢ }
sub ğ“¶ (Int \ğ“†‰) {
    my \ğ“¢ = [Â«'' ğ“º ğ“» ğ“¼ ğ“½ ğ“¾ ğ“¿ ğ“€ ğ“ ğ“‚Â»], [Â«'' ğ“† ğ“ ğ“ ğ“‘ ğ“Š ğ“‹ ğ“Œ ğ“ ğ“Â»],
      [Â«'' ğ“¢ ğ“£ ğ“¤ ğ“¥ ğ“¦ ğ“§ ğ“¨ ğ“© ğ“ªÂ»], [Â«'' ğ“†¼ ğ“†½ ğ“†¾ ğ“†¿ ğ“‡€ ğ“‡ ğ“‡‚ ğ“‡ƒ ğ“‡„Â»],
      [Â«'' ğ“‚­ ğ“‚® ğ“‚¯ ğ“‚° ğ“‚± ğ“‚² ğ“‚³ ğ“‚´ ğ“‚µÂ»], ['ğ“†' Xx ^ğ“†], ['ğ“¨' Xx ^ğ“†];
    ([~] ğ“†‰.polymod( ğ“† xx * ).map( { ğ“¢[$++;$_] } ).reverse) || 'ğ“„¤'
}

sub infix:<ğ“…“> (Int $ğ“‚€ is copy where ğ“„¤ ğ“‚» ğ“„Š ğ“ˆ * ğ“ˆ ğ“„°, Int \ğ“Œ³ where ğ“„¤ ğ“ˆ * ğ“ˆ ğ“„°) {
    my $ğ“¦ = ğ“„¤;
    ([ğ“„Š,ğ“Œ³], { [.[ğ“„¤] ğ“‚½ .[ğ“„¤], .[ğ“„Š] ğ“‚½ .[ğ“„Š]] } â€¦ ^$ğ“‚€ ğ“ˆ *.[ğ“„Š])
      .reverse.map: { $ğ“‚€ ğ“‚»= .[ğ“„Š], $ğ“¦ ğ“‚½= .[ğ“„¤] if .[ğ“„Š] ğ“ˆ ($ğ“‚€ ğ“‚½ ğ“„Š) }
    $ğ“¦, $ğ“‚€;
}

#TESTING
for 580,34, 578,34, 2300578,23517 -> \ğ“ƒ¾, \ğ“†™ {
    printf "%s divmod %s = %s remainder %s =OR= %s ğ“…“ %s = %s remainder %s\n",
        ğ“ƒ¾, ğ“†™, |(ğ“ƒ¾ ğ“…“ ğ“†™), (ğ“ƒ¾, ğ“†™, |(ğ“ƒ¾ ğ“…“ ğ“†™))Â».&ğ“¶;
}
