(defun modulo-power (base power modulus)
  (loop with square = 1
        for bit across (format nil "~b" power)
        do (setf square (* square square))
        when (char= bit #\1) do (setf square (* square base))
        do (setf square (mod square modulus))
        finally (return square)))

(defun mersenne-prime-p (power)
  (do* ((N (1- (expt 2 power)))
        (sqN (isqrt N))
        (k 1 (1+ k))
        (q (1+ (* 2 power k)) (1+ (* 2 power k)))
        (m (mod q 8) (mod q 8)))
      ((> q sqN) (values t))
    (when (and (or (= 1 m) (= 7 m))
               (primep q)
               (= 1 (modulo-power 2 power q)))
      (return (values nil q)))))
