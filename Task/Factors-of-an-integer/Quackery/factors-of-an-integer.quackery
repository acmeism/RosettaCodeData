  [ 1
    [ 2dup < not while
      2 << again ]
    0
    [ over 1 > while
      dip [ 2 >> 2dup - ]
      dup 1 >> unrot -
      dup 0 < iff drop
      else
        [ 2swap nip
          rot over + ]
      again ] nip swap ]       is isqrt   (   n --> n n )

  [ [] swap
    dup isqrt 0 = dip
      [ times
        [ dup i^ 1+ /mod iff
            drop done
          rot join
          i^ 1+ join swap ]
       drop
       dup size 2 / split ]
    if [ -1 split drop ]
    swap join ]                is factors (   n --> [  )

  20 times
    [ i^ 1+ dup
      dup 10 < if sp
      echo
      say ": "
      factors witheach
        [ echo i if say ", " ]
      cr ]
