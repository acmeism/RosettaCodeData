BEGIN

INTEGER N, LEN, YES, NO, LIMIT, LONGEST, NLONG;

% RETURN P MOD Q %
INTEGER FUNCTION MOD(P, Q);
INTEGER P, Q;
BEGIN
  MOD := P - Q * (P / Q);
END;

% COMPUTE AND OPTIONALLY DISPLAY HAILSTONE SEQUENCE FOR N. %
% RETURN LENGTH OF SEQUENCE OR ZERO ON OVERFLOW. %
INTEGER FUNCTION HAILSTONE(N, DISPLAY);
INTEGER N, DISPLAY;
BEGIN
  INTEGER LEN;
  LEN := 1;
  IF DISPLAY = 1 THEN WRITE("");
  WHILE (N <> 1) AND (N > 0) DO
    BEGIN
      IF DISPLAY = 1 THEN WRITEON(N,"  ");
      IF MOD(N,2) = 0 THEN
         N := N / 2
      ELSE
         N := (N * 3) + 1;
      LEN := LEN + 1;
    END;
  IF DISPLAY = 1 THEN WRITEON(N);
  HAILSTONE := (IF N < 0 THEN 0 ELSE LEN);
END;

% EXERCISE THE FUNCTION %
YES := 1; NO := 0;
WRITE("DISPLAY HAILSTONE SEQUENCE FOR WHAT NUMBER?");
READ(N);
LEN := HAILSTONE(N, YES);
WRITE("SEQUENCE LENGTH =", LEN);

% FIND LONGEST SEQUENCE BEFORE OVERFLOW %
N := 2;
LONGEST := 1;
LEN := 2;
NLONG := 2;
LIMIT := 1000;
WRITE("SEARCHING FOR LONGEST SEQUENCE UP TO N =",LIMIT," ...");
WHILE (N < LIMIT) AND (LEN <> 0) DO
  BEGIN
    LEN := HAILSTONE(N, NO);
    IF LEN > LONGEST THEN
       BEGIN
          LONGEST := LEN;
          NLONG := N;
       END;
    N := N + 1;
  END;
IF LEN = 0 THEN WRITE("SEARCH TERMINATED WITH OVERFLOW AT N =",N-1);
WRITE("MAXIMUM SEQUENCE LENGTH =", LONGEST, " FOR N =", NLONG);

END
