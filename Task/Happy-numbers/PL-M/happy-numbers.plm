100H:

/* FIND SUM OF SQUARE OF DIGITS OF NUMBER */
DIGIT$SQUARE: PROCEDURE (N) BYTE;
    DECLARE (N, T, D) BYTE;
    T = 0;
    DO WHILE N > 0;
        D = N MOD 10;
        T = T + D * D;
        N = N / 10;
    END;
    RETURN T;
END DIGIT$SQUARE;

/* CHECK IF NUMBER IS HAPPY */
HAPPY: PROCEDURE (N) BYTE;
    DECLARE (N, I) BYTE;
    DECLARE FLAG (256) BYTE;

    DO I=0 TO 255;
        FLAG(I) = 0;
    END;

    DO WHILE NOT FLAG(N);
        FLAG(N) = 1;
        N = DIGIT$SQUARE(N);
    END;

    RETURN N = 1;
END HAPPY;

/* CP/M BDOS CALL */
BDOS: PROCEDURE (FN, ARG);
    DECLARE FN BYTE, ARG ADDRESS;
    GO TO 5;
END BDOS;

/* PRINT STRING */
PRINT: PROCEDURE (STR);
    DECLARE STR ADDRESS;
    CALL BDOS(9, STR);
END PRINT;

/* PRINT NUMBER */
PRINT$NUMBER: PROCEDURE (N);
    DECLARE S (6) BYTE INITIAL ('...',13,10,'$');
    DECLARE P ADDRESS;
    DECLARE (N, C BASED P) BYTE;
    P = .S(3);
DIGIT:
    P = P - 1;
    C = (N MOD 10) + '0';
    N = N / 10;
    IF N > 0 THEN GO TO DIGIT;
    CALL PRINT(P);
END PRINT$NUMBER;

/* FIND FIRST 8 HAPPY NUMBERS */
DECLARE SEEN BYTE INITIAL (0);
DECLARE N BYTE INITIAL (1);

DO WHILE SEEN < 8;
    IF HAPPY(N) THEN DO;
        CALL PRINT$NUMBER(N);
        SEEN = SEEN + 1;
    END;
    N = N + 1;
END;

CALL BDOS(0,0);
EOF
