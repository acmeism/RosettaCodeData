100H:

/* FIND THE SUM OF THE DIGITS OF A 16-BIT NUMBER */
DIGIT$SUM: PROCEDURE(N) BYTE;
    DECLARE N ADDRESS, SUM BYTE;
    SUM = 0;
    DO WHILE N > 0;
        SUM = SUM + (N MOD 10);
        N = N / 10;
    END;
    RETURN SUM;
END DIGIT$SUM;

/* FIND THE NEXT HARSHAD NUMBER ABOVE N */
NEXT$HARSHAD: PROCEDURE(N) ADDRESS;
    DECLARE N ADDRESS;
NEXT:
    N = N + 1;
    IF N MOD DIGIT$SUM(N) = 0 THEN
        RETURN N;
    ELSE
        GO TO NEXT;
END NEXT$HARSHAD;

/* CP/M SYSCALL */
BDOS: PROCEDURE(FUNC, ARG);
    DECLARE FUNC BYTE, ARG ADDRESS;
    GO TO 5;
END BDOS;

/* PRINT A STRING */
PRINT$STRING: PROCEDURE(STRING);
    DECLARE STRING ADDRESS;
    CALL BDOS(9, STRING);
END PRINT$STRING;

/* PRINT A NUMBER */
PRINT$NUMBER: PROCEDURE(N);
    DECLARE S (7) BYTE INITIAL ('..... $');
    DECLARE (N, P) ADDRESS, (C BASED P) BYTE;
    P = .S(5);
DIGIT:
    P = P - 1;
    C = (N MOD 10) + '0';
    N = N / 10;
    IF N > 0 THEN GO TO DIGIT;
    CALL PRINT$STRING(P);
END PRINT$NUMBER;

DECLARE CRLF DATA (13,10,'$');
DECLARE N ADDRESS INITIAL (0), S BYTE;

/* PRINT FIRST 20 HARSHADS */
CALL PRINT$STRING(.'FIRST 20: $');
DO S = 1 TO 20;
    CALL PRINT$NUMBER(N := NEXT$HARSHAD(N));
END;
CALL PRINT$STRING(.CRLF);

/* PRINT HARSHAD NUMBER ABOVE 1000 */
CALL PRINT$STRING(.'FIRST ABOVE 1000: $');
CALL PRINT$NUMBER(NEXT$HARSHAD(1000));
CALL PRINT$STRING(.CRLF);

CALL BDOS(0,0);
EOF
