100H:

/* FIND JEWELS AMONG STONES */
COUNT$JEWELS: PROCEDURE (JEWELS, STONES) BYTE;
    DECLARE (JEWELS, STONES) ADDRESS;
    DECLARE (J BASED JEWELS, S BASED STONES) BYTE;
    DECLARE JFLAG (256) BYTE, I BYTE;

    /* ZERO JEWEL FLAGS */
    DO I=0 TO 255;
        JFLAG(I) = 0;
    END;

    /* LOOP THROUGH JEWELS AND MARK THEM */
    DO WHILE J <> '$';
        JFLAG(J) = 1;
        JEWELS = JEWELS + 1;
    END;

    /* COUNT THE JEWELS AMONG THE STONES */
    I = 0;
    DO WHILE S <> '$';
        I = I + JFLAG(S);
        STONES = STONES + 1;
    END;
    RETURN I;
END COUNT$JEWELS;

/* CP/M BDOS CALL */
BDOS: PROCEDURE (FN, ARG);
    DECLARE FN BYTE, ARG ADDRESS;
    GO TO 5;
END BDOS;

PRINT: PROCEDURE (STR);
    DECLARE STR ADDRESS;
    CALL BDOS(9, STR);
END PRINT;

/* NUMERIC OUTPUT */
PRINT$NUMBER: PROCEDURE (N);
    DECLARE S (4) BYTE INITIAL ('...$');
    DECLARE P ADDRESS, (N, C BASED P) BYTE;
    P = .S(3);
DIGIT:
    P = P-1;
    C = N MOD 10 + '0';
    N = N/10;
    IF N > 0 THEN GO TO DIGIT;
    CALL PRINT(P);
END PRINT$NUMBER;

/* PRINT JEWELS, STONES, AND AMOUNT OF JEWELS IN STONES */
TEST: PROCEDURE (J, S);
    DECLARE (J, S) ADDRESS;
    CALL PRINT(.'''$');
    CALL PRINT(J);
    CALL PRINT(.''' IN ''$');
    CALL PRINT(S);
    CALL PRINT(.''': $');
    CALL PRINT$NUMBER(COUNT$JEWELS(J, S));
    CALL PRINT(.(13,10,'$'));
END TEST;

/* UNFORTUNATELY, THE PL/M COMPILER ACCEPTS A VERY RESTRICTED CHARACTER SET
   IN THE SOURCE CODE. (IT IS THE INTERSECTION OF VARIOUS POPULAR CHARSETS
   FROM THE 1960S.) THIS CHARACTER SET DOES NOT INCLUDE LOWERCASE LETTERS.
   HOWEVER, THIS CODE ASSUMES THE ASCII CHARACTER SET ANYWAY.
   WE CAN INCLUDE LOWERCASE LETTERS ... BY WRITING THEIR ASCII CODES.
   THE OUTPUT WILL BE CORRECT OF COURSE. */

CALL TEST(.( 97,'A$' ), .( 97,'AA',98,98,98,98,'$' ));
CALL TEST(.( 122,'$' ), .( 'ZZZZ$' ));

CALL BDOS(0,0);
EOF
