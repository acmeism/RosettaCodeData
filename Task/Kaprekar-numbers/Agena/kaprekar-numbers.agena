scope # find some Kaprekar numbers

    # returns TRUE if n is a Kaprekar number, FALSE otherwise
    local constant isKaprekar := proc( n :: number ) :: boolean is
        if   n < 1 then # 0 and -ve numbers are not Kaprekar numbers
            return false
        elif n = 1 then  # 1 is defined to be a Kaprekar number
            return true
        elif n mod 9 > 1 then # can't be Kapreker - see notes on the Maple sample
            return false
        else
            # n is a Kaprekar number if the digits of its
            # square can be partitioned into two numbers
            # that sum to n
            local constant nSquared   := n * n;
            local          powerOfTen := 10;
            local          result     := false;
            while nSquared > powerOfTen and not result do
                local constant leftPart  := nSquared  \  powerOfTen;
                local constant rightPart := nSquared mod powerOfTen;
                result := ( leftPart + rightPart ) = n and rightPart <> 0;
                powerOfTen *:= 10
            od;
            return result
        fi
    end

    # find the Kaprekar numbers up to 1 000 000
    # printing all those below 10 000
    scope
        local constant maxNumber    := 1_000_000;
        local          kn           := seq();
        for n to maxNumber do
            if isKaprekar( n ) then
                kn[ size kn + 1 ] := n
            fi
        od;
        printf( "Kaprekar numbers below 10 000:" );
        for i while kn[ i ] < 10_000 do printf( " %d", kn[ i ] ) od;
        printf( "\nThere are %d Kaprekar numbers below %d\n", size kn, maxNumber )
    end
end
