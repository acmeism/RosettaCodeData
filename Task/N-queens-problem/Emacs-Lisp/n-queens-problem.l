(let ((*result* '()))
  (defun grid-cnt (n)
    (* n n) )
  (defun x-axis (n pos)
    (/ pos n) )
  (defun y-axis (n pos)
    (% pos n) )
  (defun chess-cnt (chess-map)
    (seq-count (lambda (x) x) chess-map))
  (defun check-conflict (n chess-map pos)
    (let ((is-conflict nil))
      (cl-loop for i from 0 to (1- (grid-cnt n)) while (not is-conflict) do
	       (when (aref chess-map i)
		 (when (or (= (x-axis n i) (x-axis n pos))
			   (= (y-axis n i) (y-axis n pos))
			   (= (abs (- (x-axis n i) (x-axis n pos)))
			      (abs (- (y-axis n i) (y-axis n pos))))
			   )
		   (setq is-conflict 't)
		   )
		 )
	       )
      is-conflict )
    )

  (defun place-chess (n chess-map start-pos)
    (if (< (chess-cnt chess-map) n)
	(progn
	  (let ()
	    (cl-loop for i from start-pos to (1- (grid-cnt n)) do
		     (when (not (aref chess-map i)) ;; check if place is empty
		       ;; check if place is on hold by other chess
		       (when (not (check-conflict n chess-map i))
			 (let ((map1 (copy-sequence chess-map)))
			   (aset map1 i 't)
			   (place-chess n map1 i)
			   )
			 )
		       )
		     )
	    )
	  )
      (progn
	(if *result* (nconc *result* (list chess-map)) (setq *result* (list chess-map)))
	)
      )
    )

  (defun show-result (n)
    (let ()
      (seq-map (lambda (map1)
		
		 (let ((map-txt ""))
		   (message ">>>>>>>>>>>>>>")
		   (seq-map-indexed (lambda (elm idx)
				      (if (= (% idx n) 0)
					  ;;(setq map-text (concat map-txt "\n"))
					  (progn
					    (message map-txt)
					    (setq map-txt "") )
					)
				      (setq map-txt
					    (concat map-txt (if elm "✓" "⓪")))
				      ) map1)
		   (message "<<<<<<<<<<<<<<\n")
		   )
		 ) *result*)
      )
    (message "%d solutions in total" (length *result*))
    )

  (defun start-calculate (n)
    (let ((chess-map (make-vector (grid-cnt n) nil)))
      (place-chess n chess-map 0)
      )
    (show-result n)
    )

  (start-calculate 8)
  )
