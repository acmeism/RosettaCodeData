DEFINE PROCEDURE ''DIVIDE'' [A,B]:
BLOCK 0: BEGIN
  IF A < B, THEN:
    QUIT BLOCK 0;
  CELL(0) <= 1;
  OUTPUT <= 1;
  LOOP AT MOST A TIMES:
  BLOCK 2: BEGIN
    IF OUTPUT * B = A, THEN:
    QUIT BLOCK 0;
    OUTPUT <= OUTPUT + 1;
    IF OUTPUT * B > A, THEN:
    BLOCK 3: BEGIN
      OUTPUT <= CELL(0);
      QUIT BLOCK 0;
    BLOCK 3: END;
    CELL(0) <= OUTPUT;
  BLOCK 2: END;
BLOCK 0: END.

DEFINE PROCEDURE ''MINUS'' [A,B]:
BLOCK 0: BEGIN
  IF A < B, THEN:
    QUIT BLOCK 0;
  LOOP AT MOST A TIMES:
  BLOCK 1: BEGIN
    IF OUTPUT + B = A, THEN:
      QUIT BLOCK 0;
    OUTPUT <= OUTPUT + 1;
  BLOCK 1: END;
BLOCK 0: END.

DEFINE PROCEDURE ''MODULUS'' [A,B]:
BLOCK 0: BEGIN
  CELL(0) <= DIVIDE[A,B];
  OUTPUT <= MINUS[A,CELL(0) * B];
BLOCK 0: END.

DEFINE PROCEDURE ''PLAYER_TURN'' [TOKENS_LEFT, TAKE]:
BLOCK 0: BEGIN
  CELL(0) <= TAKE;

  IF TAKE > 3, THEN:
  BLOCK 1: BEGIN
    CELL(0) <= MODULUS [TAKE, 3] + 1;
    PRINT ['take must be between 1 and 3. setting take to ', CELL(0), '.'];
  BLOCK 1: END;

  IF TAKE < 1, THEN:
  BLOCK 2: BEGIN
    CELL(0) <= 1;
    PRINT ['take must be between 1 and 3. setting take to 1.'];
  BLOCK 2: END;

  OUTPUT <= MINUS [TOKENS_LEFT, CELL(0)];

  PRINT ['player takes ', CELL(0), ' tokens.'];
  PRINT ['tokens remaining: ', OUTPUT];
  PRINT [''];
BLOCK 0: END.

DEFINE PROCEDURE ''COMPUTER_TURN'' [TOKENS_LEFT]:
BLOCK 0: BEGIN
  CELL(0) <= MODULUS [TOKENS_LEFT, 4];
  OUTPUT <= MINUS [TOKENS_LEFT, CELL(0)];

  PRINT ['computer takes ', CELL(0), ' tokens.'];
  PRINT ['tokens remaining: ', OUTPUT];
  PRINT [''];
BLOCK 0: END.

DEFINE PROCEDURE ''PLAY_GAME'' [FST, SEC, THD]:
BLOCK 0: BEGIN
  CELL(0) <= FST;
  CELL(1) <= SEC;
  CELL(2) <= THD;
  OUTPUT <= 12;

  LOOP 3 TIMES:
  BLOCK 1: BEGIN
    OUTPUT <= PLAYER_TURN [OUTPUT, CELL(0)];
    CELL(0) <= CELL(1);
    CELL(1) <= CELL(2);

    OUTPUT <= COMPUTER_TURN [OUTPUT];
  BLOCK 1: END;

  PRINT ['computer wins!'];
BLOCK 0: END.

PLAY_GAME [1,4,3];
