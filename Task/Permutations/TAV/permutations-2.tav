\(  Calculate all permutations of integers 1..n

    Second variant: two arrays, recursive, reverse lexical order.
    Array (a) has the remaining elements which are each appended to the
    array (t), removed and the rest applied to the expanded (t).
    The elements of row (a) may have any value; only void or not void is used.
\)
\c  Use native mode (symbols instead of keywords, class functions)
permute2 (a) to (t):
  l =: a.Count                  \ number of non-void elements
  ? l > 0
    ?# i =: row a give keys     \ of non-void elements only
      t[l] =: i
      a[i] =: ()                \ decrements a.Count
      permute2 a to t
      a[i] =: i                 \ any non-void value
    :>
  \ print result in reverse order; output requires most CPU time
  print tuple t::as tuple transpose


\(  command line parameter is number of elements
\)
main (parms):+
  n =: string parms[1] as integer else 3
  a =: new row from 1 upto n    \ fill 1..n
  t =: new row size n           \ intially void
  permute2 a to t
