# using an implied parameter .f ...
val .pricefrac = f given .f {
    case >= 0.00, < 0.06: 0.10
    case >= 0.06, < 0.11: 0.18
    case >= 0.11, < 0.16: 0.26
    case >= 0.16, < 0.21: 0.32
    case >= 0.21, < 0.26: 0.38
    case >= 0.26, < 0.31: 0.44
    case >= 0.31, < 0.36: 0.50
    case >= 0.36, < 0.41: 0.54
    case >= 0.41, < 0.46: 0.58
    case >= 0.46, < 0.51: 0.62
    case >= 0.51, < 0.56: 0.66
    case >= 0.56, < 0.61: 0.70
    case >= 0.61, < 0.66: 0.74
    case >= 0.66, < 0.71: 0.78
    case >= 0.71, < 0.76: 0.82
    case >= 0.76, < 0.81: 0.86
    case >= 0.81, < 0.86: 0.90
    case >= 0.86, < 0.91: 0.94
    case >= 0.91, < 0.96: 0.98
    case >= 0.96, <= 1.00: 1.00
    default: throw "bad data"

    # The default operator between test cases is "and".
    # That is, writing "case" without a logical operator is the same as writing "case and".
    # To make a given case act as a switch case does in other languages, use "case or".
}

writeln .pricefrac(0.17)
writeln .pricefrac(0.71)
