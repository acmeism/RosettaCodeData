;; put info string in permanent storage for later use
(info 'make-Q
"usage: (define q (make-Q)) ;  (q '[top | empty? | pop | push value | to-list | from-list list])")

;; make-Q
(define (make-Q)
  (let ((q (make-vector 0)))
    (lambda (message . args)
      (case message
        ((empty?) (vector-empty? q))
        ((top) (if (vector-empty? q) (error  'Q:top:empty q) (vector-ref q 0)))
        ((push) (vector-push q (car args)))
        ((pop) (if (vector-empty? q) (error 'Q:pop:empty q) (vector-shift q)))
        ((to-list) (vector->list q))
        ((from-list) (set! q (list->vector (car args))) q )
        (else (info 'make-Q) (error  "Q:bad message:" message )))))) ; display info if unknown message

;;
(define q (make-Q))
(q 'empty?) â†’ #t
(q 'push 'first) â†’ first
(q 'push 'second) â†’ second
(q 'pop) â†’ first
(q 'pop) â†’ second
(q 'top)
"ðŸ’¬ error: Q:top:empty #()"
(q 'from-list '( 6 7 8)) â†’ #( 6 7 8)
(q 'top) â†’ 6
(q 'pop) â†’ 6
(q 'to-list)â†’ (7 8)
(q 'delete)
"ðŸ’­ error: Q:bad message: delete"

;; save make-Q
(local-put 'make-Q)
