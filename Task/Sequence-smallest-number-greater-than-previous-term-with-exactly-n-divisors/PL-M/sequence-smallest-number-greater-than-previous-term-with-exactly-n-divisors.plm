100H: /* FIND THE SMALLEST NUMBER > THE PREVIOUS ONE WITH EXACTLY N DIVISORS */

   /* CP/M BDOS SYSTEM CALL */
   BDOS: PROCEDURE( FN, ARG ); DECLARE FN BYTE, ARG ADDRESS; GOTO 5; END;
   /* CONSOLE OUTPUT ROUTINES */
   PR$CHAR:   PROCEDURE( C ); DECLARE C BYTE;    CALL BDOS( 2, C );  END;
   PR$STRING: PROCEDURE( S ); DECLARE S ADDRESS; CALL BDOS( 9, S );  END;
   PR$NL:     PROCEDURE; CALL PR$STRING( .( 0DH, 0AH, '$' ) );       END;
   PR$NUMBER: PROCEDURE( N );
      DECLARE N ADDRESS;
      DECLARE V ADDRESS, N$STR( 6 ) BYTE INITIAL( '.....$' ), W BYTE;
      N$STR( W := LAST( N$STR ) - 1 ) = '0' + ( ( V := N ) MOD 10 );
      DO WHILE( ( V := V / 10 ) > 0 );
         N$STR( W := W - 1 ) = '0' + ( V MOD 10 );
      END;
      CALL PR$STRING( .N$STR( W ) );
   END PR$NUMBER;

   /* TASK */

   /* RETURNS THE DIVISOR COUNT OF N */
   COUNT$DIVISORS: PROCEDURE( N )ADDRESS;
      DECLARE N ADDRESS;
      DECLARE ( I, I2, COUNT ) ADDRESS;
      COUNT = 0;
      I     = 1;
      DO WHILE( ( I2 := I * I ) < N );
         IF N MOD I = 0 THEN COUNT = COUNT + 2;
         I = I + 1;
      END;
      IF I2 = N THEN RETURN ( COUNT + 1 ); ELSE RETURN ( COUNT );
   END COUNT$DIVISORS ;

   DECLARE MAX LITERALLY '15';
   DECLARE ( I, NEXT ) ADDRESS;

   CALL PR$STRING( .'THE FIRST $' );
   CALL PR$NUMBER( MAX );
   CALL PR$STRING( .' TERMS OF THE SEQUENCE ARE:$' );
   NEXT = 1;
   I    = 1;
   DO WHILE( NEXT <= MAX );
      IF NEXT = COUNT$DIVISORS( I ) THEN DO;
         CALL PR$CHAR( ' ' );
         CALL PR$NUMBER( I );
         NEXT = NEXT + 1;
      END;
      I = I + 1;
   END;

EOF
