use_namespace(rosettacode)_me();

// Set creation
add_set(A)_values(ğŸ–,ğŸ¦¬,ğŸ¦˜,ğŸ¦«,ğŸ¦­);
add_set(B)_values(ğŸˆâ€â¬›,ğŸ¦¬,ğŸ¦«,ğŸ¦¤,ğŸ);
add_set(C)_values(ğŸˆâ€â¬›,ğŸ¦«);
add_set(M)_value(ğŸ–);

// Membership
ms_msg()_calc([M]âˆˆ[B])
    ? with_msg()_msg(set M is an element in set B);
    : with_msg()_msg(set M is not an element in set B);
;

ms_msg()_calc(ğŸ–âˆˆ[A])
    ? with_msg()_msg(ğŸ– is an element in set A);
    : with_msg()_msg(ğŸ– is not an element in set A);
;

// Union
ms_msg()_msg(AâˆªB=[])_calc([A]âˆª[B]);

// Intersection
ms_msg()_msg(Aâˆ©B=[])_calc([A]âˆ©[B]);

// Difference
ms_msg()_msg(Aâˆ–B=[])_calc([A]âˆ–[B]);   // U+2216 is used not U+005c (\)
ms_msg()_msg(A\\B=[])_calc([A]\\[B]); // U+005c (\) has to be escaped

// Subset
ms_msg()_calc([C]âŠ†[A])
    ? with_msg()_msg(set C is a subset of set A);
    : with_msg()_msg(set C is not a subset of set A);
;

ms_msg()_calc([C]âŠ†[B])
    ? with_msg()_msg(set C is a subset of set B);
    : with_msg()_msg(set C is not a subset of set B);
;

// Equality
ms_msg()_calc([A]=[B])
    ? with_msg()_msg(set A is equal to set B);
    : with_msg()_msg(set A is not equal to set B);
;

// Test
ms_msg()_calc([A]âŠ‚[B])_or()_calc([A]âŠŠ[B])
    ? with_msg()_msg(set A is a proper subset of set B);
    : with_msg()_msg(set A is not a proper subset of set B);
;

ms_msg()_calc([C]âŠ‚[B]||[C]âŠŠ[B])     // alternative syntax
    ? with_msg()_msg(set C is a proper subset of set B);
    : with_msg()_msg(set C is not a proper subset of set B);
;

// Modify a mutable set (all sets are mutable)
with_set(M)_push(ğŸ¦¬,ğŸ¦˜,ğŸ¦«,ğŸ¦­);
ms_msg()_calc([M]=[A])
    ? with_msg()_msg(set M is equal to set A);
    : with_msg()_msg(set M is not equal to set A);
;

reset_namespace[];
