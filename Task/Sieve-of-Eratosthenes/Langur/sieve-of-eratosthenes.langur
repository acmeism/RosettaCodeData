val .sieve = f(.limit) {
    if .limit < 2 {
        return []
    }

    var .composite = arr .limit, false
    .composite[1] = true

    for .n in 2 to truncate(.limit ^/ 2) + 1 {
        if not .composite[.n] {
            for .k = .n^2; .k < .limit; .k += .n {
                .composite[.k] = true
            }
        }
    }

    filter f(.n) not .composite[.n], series .limit-1
}

writeln .sieve(100)
