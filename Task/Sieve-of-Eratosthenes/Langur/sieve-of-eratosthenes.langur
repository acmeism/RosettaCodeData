val .sieve = fn(.limit) {
    if .limit < 2: return []

    var .composite = .limit * [false]
    .composite[1] = true

    for .n in 2 .. trunc(.limit ^/ 2) + 1 {
        if not .composite[.n] {
            for .k = .n^2 ; .k < .limit ; .k += .n {
                .composite[.k] = true
            }
        }
    }

    filter fn(.n) not .composite[.n], series .limit-1
}

writeln .sieve(100)
