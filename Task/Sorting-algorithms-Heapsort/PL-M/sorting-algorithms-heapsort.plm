100H:

/* HEAP SORT AN ARRAY OF 16-BIT INTEGERS */
HEAP$SORT: PROCEDURE (AP, COUNT);
    SIFT$DOWN: PROCEDURE (AP, START, ENDV);
        DECLARE (AP, A BASED AP) ADDRESS;
        DECLARE (START, ENDV, ROOT, CHILD, TEMP) ADDRESS;
        ROOT = START;

        DO WHILE (CHILD := SHL(ROOT,1) + 1) <= ENDV;
            IF CHILD + 1 <= ENDV AND A(CHILD) < A(CHILD+1) THEN
                CHILD = CHILD + 1;
            IF A(ROOT) < A(CHILD) THEN DO;
                TEMP = A(ROOT);
                A(ROOT) = A(CHILD);
                A(CHILD) = TEMP;
                ROOT = CHILD;
            END;
            ELSE RETURN;
        END;
    END SIFT$DOWN;

    HEAPIFY: PROCEDURE (AP, COUNT);
        DECLARE (AP, COUNT, START) ADDRESS;
        START = (COUNT-2) / 2;
    LOOP:
        CALL SIFT$DOWN(AP, START, COUNT-1);
        IF START = 0 THEN RETURN;
        START = START - 1;
        GO TO LOOP;
    END HEAPIFY;

    DECLARE (AP, COUNT, ENDV, TEMP, A BASED AP) ADDRESS;

    CALL HEAPIFY(AP, COUNT);
    ENDV = COUNT - 1;
    DO WHILE ENDV > 0;
        TEMP = A(0);
        A(0) = A(ENDV);
        A(ENDV) = TEMP;
        ENDV = ENDV - 1;
        CALL SIFT$DOWN(AP, 0, ENDV);
    END;
END HEAP$SORT;

/* CP/M CALLS AND FUNCTION TO PRINT INTEGERS */
BDOS: PROCEDURE (FN, ARG);
    DECLARE FN BYTE, ARG ADDRESS;
    GO TO 5;
END BDOS;

PRINT$NUMBER: PROCEDURE (N);
    DECLARE S (7) BYTE INITIAL ('..... $');
    DECLARE (N, P) ADDRESS, C BASED P BYTE;
    P = .S(5);
DIGIT:
    P = P-1;
    C = N MOD 10 + '0';
    N = N / 10;
    IF N > 0 THEN GO TO DIGIT;
    CALL BDOS(9, P);
END PRINT$NUMBER;

/* SORT AN ARRAY */
DECLARE NUMBERS (11) ADDRESS INITIAL (4, 65, 2, 31, 0, 99, 2, 8, 3, 782, 1);
CALL HEAP$SORT(.NUMBERS, LENGTH(NUMBERS));

/* PRINT THE SORTED ARRAY */
DECLARE N BYTE;
DO N = 0 TO LAST(NUMBERS);
    CALL PRINT$NUMBER(NUMBERS(N));
END;

CALL BDOS(0,0);
EOF
