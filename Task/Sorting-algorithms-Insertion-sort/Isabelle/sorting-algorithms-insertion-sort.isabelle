theory Insertionsort
  imports Main
begin

fun insert :: "int ‚áí int list ‚áí int list" where
  "insert x [] = [x]"
| "insert x (y#ys) = (if x ‚â§ y then (x#y#ys) else y#(insert x ys))"

text‚ÄπExample:‚Ä∫
lemma "insert 4 [1, 2, 3, 5, 6] = [1, 2, 3, 4, 5, 6]" by(code_simp)

fun insertionsort :: "int list ‚áí int list" where
  "insertionsort [] = []"
| "insertionsort (x#xs) = insert x (insertionsort xs)"

lemma "insertionsort [4, 2, 6, 1, 8, 1] = [1, 1, 2, 4, 6, 8]" by(code_simp)

text‚Äπ
Our function behaves the same as the \<^term>‚Äπsort‚Ä∫ function of the standard library.
‚Ä∫
lemma insertionsort: "insertionsort xs = sort xs"
proof(induction xs)
  case Nil
  show "insertionsort [] = sort []" by simp
next
  case (Cons x xs)
  text‚ÄπOur \<^const>‚Äπinsert‚Ä∫ behaves the same as the std libs \<^const>‚Äπinsort‚Ä∫.‚Ä∫
  have "insert a as = insort a as" for a as by(induction as) simp+
  with Cons show "insertionsort (x # xs) = sort (x # xs)" by simp
qed

text‚Äπ
Given that we behave the same as the std libs sorting algorithm,
we get the correctness properties for free.
‚Ä∫
corollary insertionsort_correctness:
  "sorted (insertionsort xs)" and
  "set (insertionsort xs) = set xs"
  using insertionsort by(simp)+

text‚Äπ
The Haskell implementation from
üåê‚Äπhttps://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort#Haskell‚Ä∫
also behaves the same. Ultimately, they all return a sorted list.
One exception to the Haskell implementation is that the type signature of
\<^const>‚Äπfoldr‚Ä∫ in Isabelle is slightly different:
The initial value of the accumulator goes last.
‚Ä∫
definition rosettacode_haskell_insertionsort :: "int list ‚áí int list" where
  "rosettacode_haskell_insertionsort ‚â° Œªxs. foldr insert xs []"

lemma "rosettacode_haskell_insertionsort [4, 2, 6, 1, 8, 1] =
       [1, 1, 2, 4, 6, 8]" by(code_simp)

lemma "rosettacode_haskell_insertionsort xs = insertionsort xs"
  unfolding rosettacode_haskell_insertionsort_def by(induction xs) simp+

end
