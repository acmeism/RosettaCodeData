(append) list1 list2
=========
#true
(003) "append" list1 list2

(car) pair
=========
#true
(002) "car" pair

(cadr) pair
=========
#true
(002) "cadr" pair

(cdr) pair
=========
#true
(002) "cdr" pair

(cddr) pair
=========
#true
(002) "cddr" pair

(cons) one two
=========
#true
(003) "cons" one two

(list1a) item
=========
#true
(002) "list" item

(map) function list
=========
#true
(003) "map" function list

(merge) comparator list1 list2
CONTINUE WITH COLLECT ARGUMENT
#true
(merge01) comparator list1 list2 nil

(merge01) comparator list1 list2 collect
LIST2 EXHAUSTED -> MERGED
(null?) list2
(append) (reverse) collect list1

(merge01) comparator list1 list2 collect
LIST1 EXHAUSTED -> MERGED
(null?) list1
(append) (reverse) collect list2

(merge01) comparator list1 list2 collect
TAKE FROM LIST2 (HANDLES ONE CASE)
(003) comparator (car) list2 (car) list1
(merge01) comparator
  list1
  (cdr) list2
  (cons) (car) list2 collect

(merge01) comparator list1 list2 collect
TAKE FROM LIST1 (HANDLES TWO CASES)
#true
(merge01) comparator
  (cdr) list1
  list2
  (cons) (car) list1 collect

(null?) value
=========
#true
(002) "null?" value

(reverse) list
=========
#true
(002) "reverse" list

(sort) comparator jumble
PREPARE JUMBLE AND PERFORM MERGE PASSES -> EXTRACT
#true
(car) (sort02) comparator (sort01) jumble

(sort01) jumble
PREPARED JUMBLE
#true
(map) list1a jumble

(sort02) comparator jumble
WHEN ZERO LISTS THEN NIL
(null?) jumble
nil

(sort02) comparator jumble
WHEN ONE LIST THEN ALREADY SORTED
(null?) (cdr) jumble
jumble

(sort02) comparator jumble
REPEATEDLY MERGE ALONG LENGTH
#true
(sort02) comparator
  (cons) (merge) comparator (car) jumble (cadr) jumble
    (sort02) comparator (cddr) jumble
