100H:
BDOS: PROCEDURE (FN, ARG); DECLARE FN BYTE, ARG ADDRESS; GO TO 5; END BDOS;
EXIT: PROCEDURE; CALL BDOS(0,0); END EXIT;
PRINT: PROCEDURE (S); DECLARE S ADDRESS; CALL BDOS(9,S); END PRINT;

/* PRINT NUMBER RIGHT-ALIGNED IN 7 POSITIONS */
PRINT$NUMBER: PROCEDURE (N);
    DECLARE S (7) BYTE INITIAL (' .....$');
    DECLARE N ADDRESS, I BYTE;
    I = 6;
DIGIT:
    I = I - 1;
    S(I) = N MOD 10 + '0';
    N = N / 10;
    IF N > 0 THEN GO TO DIGIT;
    DO WHILE I <> 0;
        I = I - 1;
        S(I) = ' ';
    END;
    CALL PRINT(.S);
END PRINT$NUMBER;

/* COUNT AND STORE AMOUNT OF DIVISORS FOR 1..N AT VEC */
COUNT$DIVS: PROCEDURE (VEC, N);
    DECLARE (VEC, N, V BASED VEC) ADDRESS;
    DECLARE (I, J) ADDRESS;

    DO I=1 TO N;
        V(I) = 1;
    END;

    DO I=2 TO N;
        J = I;
        DO WHILE J <= N;
            V(J) = V(J) + 1;
            J = J + I;
        END;
    END;
END COUNT$DIVS;

/* GIVEN VECTOR OF COUNT OF DIVISORS, SEE IF N IS A TAU NUMBER */
TAU: PROCEDURE (VEC, N) BYTE;
    DECLARE (VEC, N, V BASED VEC) ADDRESS;
    RETURN N MOD V(N) = 0;
END TAU;

DECLARE AMOUNT LITERALLY '100';
DECLARE LIMIT LITERALLY '1100';

DECLARE SEEN BYTE INITIAL (0);
DECLARE N ADDRESS INITIAL (1);

CALL COUNT$DIVS(.MEMORY, LIMIT);
DO WHILE SEEN < AMOUNT;
    IF TAU(.MEMORY, N) THEN DO;
        CALL PRINT$NUMBER(N);
        SEEN = SEEN + 1;
        IF SEEN MOD 10 = 0 THEN CALL PRINT(.(13,10,'$'));
    END;
    N = N + 1;
END;

CALL EXIT;
EOF
