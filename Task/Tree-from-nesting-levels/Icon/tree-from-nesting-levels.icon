procedure main()
    tests := [ [], [1, 2, 4], [3, 1, 3, 1], [1, 2, 3, 1], [3, 2, 1, 3],
               [3, 3, 3, 1, 1, 3, 3, 3], [3, 3, 3, 2, 2, 3, 4, 3],
               [1, 2, 4, 2, 2, 1] ]

    every test := !tests do
        if result := tfnl(test) then
            write(limage2(test),"  --->  ",limage2(result))
        else
            write(limage2(test),"  --->  FAILED")
end

procedure tfnl(levels)
    innerlist := []
    level := levels[1] | fail
    put(r := [], nested(level,level-1,innerlist)) | fail
    /innerlist[1] := r
    every i := 2 to *levels & level := levels[i] do
        if j := i-1 to 1 by -1  &  level >= levels[j] then{
            put(innerlist[j], nested(level,level-levels[j],innerlist))
            /innerlist[i] := innerlist[j]
        }else{
            put(r, nested(level,level-1,innerlist))
            /innerlist[i] := r
        }
    return r
end

procedure nested(item,level,innerlist)
    if level = 0 then{          # special case
        put(innerlist,&null)
        return item
    }
    outer := inner := []
    every 2 to level do inner := put(inner,[])[1]
    put(inner,item)
    put(innerlist,inner)
    return outer
end

procedure limage2(L)
    if type(L) ~== "list" then return image(L)
    result := ""
    every result ||:= limage2(!L) || ","
    return ("[" || result[1:-1] || "]") | "[]"
end
